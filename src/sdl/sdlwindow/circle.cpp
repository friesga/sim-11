#include "sdlwindow.h"

// Custom function to render a copy of a circle with different radii from
// source to destination.
// Generated by Codeium.
void SDLWindow::RenderCopyCircle (SDL_Renderer* renderer, SDL_Texture* texture,
    Position sourceCenter, int sourceRadius,
    Position destCenter, int destRadius)
{
    for (int x = destCenter.x - destRadius; x < destCenter.x + destRadius; x++)
    {
        for (int y = destCenter.y - destRadius; y < destCenter.y + destRadius; y++)
        {
            if (pow (x - destCenter.x, 2) + pow (y - destCenter.y, 2) <= pow (destRadius, 2))
            {
                int sourceX = sourceCenter.x + (x - destCenter.x);
                int sourceY = sourceCenter.y + (y - destCenter.y);

                SDL_Rect sourcePixel = {sourceX, sourceY, 1, 1};
                SDL_Rect destPixel = {x, y, 1, 1};

                SDL_RenderCopy (renderer, texture, &sourcePixel, &destPixel);
            }
        }
    }
}

// Source: https://gist.github.com/Gumichan01/332c26f6197a432db91cc4327fcabb1c
// 
// This source code is under the MIT License
int SDLWindow::RenderDrawCircle (SDL_Renderer* renderer, Position position,
    int radius)
{
    int offsetx, offsety, d;
    int status;

    offsetx = 0;
    offsety = radius;
    d = radius - 1;
    status = 0;

    while (offsety >= offsetx)
    {
        status += SDL_RenderDrawPoint (renderer, position.x + offsetx,
            position.y + offsety);
        status += SDL_RenderDrawPoint (renderer, position.x + offsety,
            position.y + offsetx);
        status += SDL_RenderDrawPoint (renderer, position.x - offsetx,
            position.y + offsety);
        status += SDL_RenderDrawPoint (renderer, position.x - offsety,
            position.y + offsetx);
        status += SDL_RenderDrawPoint (renderer, position.x + offsetx,
            position.y - offsety);
        status += SDL_RenderDrawPoint (renderer, position.x + offsety,
            position.y - offsetx);
        status += SDL_RenderDrawPoint (renderer, position.x - offsetx,
            position.y - offsety);
        status += SDL_RenderDrawPoint (renderer, position.x - offsety,
            position.y - offsetx);

        if (status < 0)
        {
            status = -1;
            break;
        }

        if (d >= 2 * offsetx)
        {
            d -= 2 * offsetx + 1;
            offsetx += 1;
        }
        else if (d < 2 * (radius - offsety))
        {
            d += 2 * offsety - 1;
            offsety -= 1;
        }
        else
        {
            d += 2 * (offsety - offsetx - 1);
            offsety -= 1;
            offsetx += 1;
        }
    }

    return status;
}

#ifdef UNUSED_CODE

int SDLWindow::RenderFillCircle (SDL_Renderer* renderer, int x, int y, int radius)
{
    int offsetx, offsety, d;
    int status;

    offsetx = 0;
    offsety = radius;
    d = radius - 1;
    status = 0;

    while (offsety >= offsetx)
    {

        status += SDL_RenderDrawLine (renderer, x - offsety, y + offsetx,
            x + offsety, y + offsetx);
        status += SDL_RenderDrawLine (renderer, x - offsetx, y + offsety,
            x + offsetx, y + offsety);
        status += SDL_RenderDrawLine (renderer, x - offsetx, y - offsety,
            x + offsetx, y - offsety);
        status += SDL_RenderDrawLine (renderer, x - offsety, y - offsetx,
            x + offsety, y - offsetx);

        if (status < 0)
        {
            status = -1;
            break;
        }

        if (d >= 2 * offsetx)
        {
            d -= 2 * offsetx + 1;
            offsetx += 1;
        }
        else if (d < 2 * (radius - offsety))
        {
            d += 2 * offsety - 1;
            offsety -= 1;
        }
        else
        {
            d += 2 * (offsety - offsetx - 1);
            offsety -= 1;
            offsetx += 1;
        }
    }

    return status;
}

#endif // UNUSED_CODE